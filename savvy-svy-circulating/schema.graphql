##########################################################
##                                                      ##
## THIS FILE IS AUTOGENERATED BY ./setup/buildSchema.ts ##
##                DO NOT EDIT DIRECTLY                  ##
##                                                      ##
##########################################################

enum Network {
  ARBITRUM_ONE
  ARBITRUM_GOERLI
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC # aka BNB Chain
  CELO
  COSMOS
  CRONOS
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

###########################
## Blockchain Primitives ##
###########################

type Block @entity {
  " Block number "
  id: ID!

  " Block number "
  number: BigInt!

  " Block hash "
  hash: Bytes!

  " Timestamp of this block "
  timestamp: BigInt!

  " List of events related to this block "
  events: [Event!]! @derivedFrom(field: "block")

  " List of transactions in this block "
  transactions: [Transaction!]! @derivedFrom(field: "block")
}

type Transaction @entity {
  " Transaction hash "
  id: ID!

  " Transaction hash "
  hash: Bytes!

  " Transaction input data "
  input: Bytes!

  " Transaction from "
  from: Bytes

  " Transaction to "
  to: Bytes

  " Block this transaction commited on "
  block: Block!

  " Timestamp of this transaction "
  timestamp: BigInt!

  " List of events emitted by this transaction "
  events: [Event!]! @derivedFrom(field: "transaction")
}

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
interface Event {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  # " The protocol this transaction belongs to "
  # protocol: Protocol!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!
}

type Token @entity @regularPolling {
  " Smart contract address of the token "
  id: ID!

  " Name of the token, mirrored from the smart contract "
  name: String!

  " Symbol of the token, mirrored from the smart contract "
  symbol: String!

  " The number of decimal places this token uses, default to 18 "
  decimals: Int!

  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal

  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

interface Contract {
  " Contract address "
  id: ID!
}

type Protocol @entity {
  " Overall protocol metrics "
  id: ID!

  " The total active holders "
  totalSVYHolders: Int!

  " The total active stakers "
  totalSVYStakers: Int!

  " The total active veSVY holders "
  totalVeSVYHolders: Int!

  " The total circulating SVY "
  circulatingSVY: BigInt!

  " The last timestamp circulating SVY was updated "
  lastCirculatingSVYUpdatedTimestamp: BigInt!

  "Protocol snapshots"
  snapshots: [ProtocolSnapshot!]! @derivedFrom(field: "protocol")
}

type ProtocolSnapshot @entity {
  "(Overall protocol metrics)-(timstamp)"
  id: ID!

  "The protocol this snapshot belongs to"
  protocol: Protocol!

  "The time between snapshots in seconds"
  period: Int!

  " The timestamp of the snapshot "
  timestamp: BigInt!

  " The total active holders "
  totalSVYHolders: Int!

  " The total active stakers "
  totalSVYStakers: Int!

  " The total active veSVY holders "
  totalVeSVYHolders: Int!

  " The total circulating SVY "
  circulatingSVY: BigInt!

  " The last timestamp circulating SVY was updated "
  lastCirculatingSVYUpdatedTimestamp: BigInt!
}

#########################
##### Savvy Account #####
#########################
type Account @entity {
  " The wallet address of the holder "
  id: ID!

  " The name of the holder (if the holder is known) "
  name: String

  " The balance of SVY tokens held by this account "
  svyBalance: BigInt!

  " The USD value of this account's SVY balance "
  svyBalanceUSD: BigDecimal!

  " The amount of staked SVY "
  stakedSVY: BigInt!

  " The balance of veSVY tokens held by this account "
  veSVYBalance: BigInt!

  " The amount of earning SVY per second "
  svyEarnRatePerSec: BigInt!

  " The amount of earning VeSVY per second "
  veSVYEarnRatePerSec: BigInt!

  " The amount of maximum earnable VeSVY "
  maxVeSvyEarnable: BigInt!

  " The last block number this account was updated "
  lastUpdatedBN: BigInt!

  " The last timestamp this account was updated "
  lastUpdatedTimestamp: BigInt!

  "Account snapshots"
  snapshots: [AccountSnapshot!]! @derivedFrom(field: "account")
}

type AccountSnapshot @entity {
  "(The address of the account)-(timstamp)"
  id: ID!

  "The account this snapshot belongs to"
  account: Account!

  "The time between snapshots in seconds"
  period: Int!

  " The timestamp of the snapshot "
  timestamp: BigInt!

  " The name of the account "
  name: String

  " The balance of SVY tokens held by snapshot account "
  svyBalance: BigInt!

  " The USD value of snapshot account's SVY balance "
  svyBalanceUSD: BigDecimal!

  " The amount of staked SVY "
  stakedSVY: BigInt!

  " The balance of veSVY tokens held by snapshot account "
  veSVYBalance: BigInt!

  " The amount of earning SVY per second "
  svyEarnRatePerSec: BigInt!

  " The amount of earning VeSVY per second "
  veSVYEarnRatePerSec: BigInt!

  " The amount of maximum earnable VeSVY "
  maxVeSvyEarnable: BigInt!
}

################
## Savvy VeSVY ##
################

type SvyTransferred implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  from: Bytes! # address
  to: Bytes! # address
  amount: BigInt!
}

type SVYSource @entity {
  " The address of the source "
  id: ID!

  " The name of the source (if known) "
  name: String

  " The total amount of SVY tokens this source has distributed "
  totalSVYDistributed: BigInt!

  " The last block number this account was updated "
  lastUpdatedBN: BigInt!

  " The last timestamp this account was updated "
  lastUpdatedTimestamp: BigInt!

  "SVYSource snapshots"
  snapshots: [SVYSourceSnapshot!]! @derivedFrom(field: "svySource")
}

type SVYSourceSnapshot @entity {
  "(The address of the svySource)-(timstamp)"
  id: ID!

  "The svySource this snapshot belongs to"
  svySource: SVYSource!

  "The time between snapshots in seconds"
  period: Int!

  " The timestamp of the snapshot "
  timestamp: BigInt!

  " The total amount of SVY tokens this source has distributed "
  totalSVYDistributed: BigInt!
}

################
## Savvy VeSVY ##
################

type VeSStaked implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  user: Bytes! # address
  amount: BigInt!
}

type VeSUnstaked implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  user: Bytes! # address
  amount: BigInt!
}

type VeSClaimed implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  user: Bytes! # address
  amount: BigInt!
}
