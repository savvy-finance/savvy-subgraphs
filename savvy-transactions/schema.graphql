##########################################################
##                                                      ##
## THIS FILE IS AUTOGENERATED BY ./setup/buildSchema.ts ##
##                DO NOT EDIT DIRECTLY                  ##
##                                                      ##
##########################################################

enum Network {
  ARBITRUM_ONE
  ARBITRUM_GOERLI
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC # aka BNB Chain
  CELO
  COSMOS
  CRONOS
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

###########################
## Blockchain Primitives ##
###########################

type Block @entity {
  " Block number "
  id: ID!

  " Block number "
  number: BigInt!

  " Block hash "
  hash: Bytes!

  " Timestamp of this block "
  timestamp: BigInt!

  " List of events related to this block "
  events: [Event!]! @derivedFrom(field: "block")

  " List of transactions in this block "
  transactions: [Transaction!]! @derivedFrom(field: "block")
}

type Transaction @entity {
  " Transaction hash "
  id: ID!

  " Transaction hash "
  hash: Bytes!

  " Transaction input data "
  input: Bytes!

  " Transaction from "
  from: Bytes

  " Transaction to "
  to: Bytes

  " Block this transaction commited on "
  block: Block!

  " Timestamp of this transaction "
  timestamp: BigInt!

  " List of events emitted by this transaction "
  events: [Event!]! @derivedFrom(field: "transaction")
}

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
interface Event {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  # " The protocol this transaction belongs to "
  # protocol: Protocol!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!
}

type Token @entity @regularPolling {
  " Smart contract address of the token "
  id: ID!

  " Name of the token, mirrored from the smart contract "
  name: String!

  " Symbol of the token, mirrored from the smart contract "
  symbol: String!

  " The number of decimal places this token uses, default to 18 "
  decimals: Int!

  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal

  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

interface Contract {
  " Contract address "
  id: ID!
}

# Subgraph Schema: Generic
# Version: 1.4.0
# See https://github.com/messari/subgraphs/blob/master/docs/SCHEMA.md for details

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
  # Will add more
}

enum RewardTokenType {
  " For reward tokens awarded to LPs/lenders "
  DEPOSIT

  " For reward tokens awarded to borrowers "
  BORROW
}

type RewardToken @entity @regularPolling {
  " { Reward token type }-{ Smart contract address of the reward token } "
  id: ID!

  " Reference to the actual token "
  token: Token!

  " The type of the reward token "
  type: RewardTokenType!
}

#############################
##### Protocol Metadata #####
#############################

type Protocol @entity @regularPolling {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, etc) "
  type: ProtocolType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]! @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")

  # " All events that belong to this protocol "
  # events: [Event!]! @derivedFrom(field: "protocol")
}

###############################
##### Protocol Timeseries #####
###############################

type UsageMetricsDailySnapshot @entity @dailySnapshot {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: Protocol!

  " Number of unique daily active users "
  dailyActiveUsers: Int!

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. "
  dailyTransactionCount: Int!

  " Total number of pools "
  totalPoolCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type UsageMetricsHourlySnapshot @entity @hourlySnapshot {
  " { # of hours since Unix epoch time } "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: Protocol!

  " Number of unique hourly active users "
  hourlyActiveUsers: Int!

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. "
  hourlyTransactionCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type FinancialsDailySnapshot @entity @dailySnapshot {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: Protocol!

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  dailySupplySideRevenueUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  dailyTotalRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

###########################
##### Pool-Level Data #####
###########################

type Pool @entity @regularPolling {
  " Smart contract address of the pool "
  id: ID!

  " The protocol this pool belongs to "
  protocol: Protocol!

  " Name of the pool (e.g. Curve.fi DAI/USDC/USDT) "
  name: String

  " Symbol of liquidity pool (e.g. 3CRV) "
  symbol: String

  # Generally protocols accept one or multiple tokens and mint tokens to the depositor to track ownership
  # Some protocols don't mint any tokens to track ownership, in that case outputToken is null.

  " Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer "
  inputTokens: [Token!]!

  " Token that is minted to track ownership of position in protocol "
  outputToken: Token

  " Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon "
  rewardTokens: [RewardToken!]

  " Creation timestamp "
  createdTimestamp: BigInt!

  " Creation block number "
  createdBlockNumber: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool in USD "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. "
  inputTokenBalances: [BigInt!]!

  " The USD value of input tokens in this pool. Should be the same order as the pool's `inputTokens` field. "
  inputTokenBalancesUSD: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]

  ##### Snapshots #####

  " Pool daily snapshots "
  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: "pool")

  " Pool hourly snapshots "
  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: "pool")
}

type PoolDailySnapshot @entity @dailySnapshot {
  " { Smart contract address of the pool }-{ # of days since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: Protocol!

  " The pool this snapshot belongs to "
  pool: Pool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool, accrued to the supply side. "
  dailySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool, accrued to the protocol. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool. "
  dailyTotalRevenueUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. "
  inputTokenBalances: [BigInt!]!

  " The USD value of input tokens in this pool. Should be the same order as the pool's `inputTokens` field. "
  inputTokenBalancesUSD: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

type PoolHourlySnapshot @entity @hourlySnapshot {
  " { Smart contract address of the pool }-{ # of hours since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: Protocol!

  " The pool this snapshot belongs to "
  pool: Pool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool, accrued to the supply side. "
  hourlySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool, accrued to the protocol. "
  hourlyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool. "
  hourlyTotalRevenueUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. "
  inputTokenBalances: [BigInt!]!

  " The USD value of input tokens in this pool. Should be the same order as the pool's `inputTokens` field. "
  inputTokenBalancesUSD: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day (not hour), in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

# Helper entity for calculating daily/hourly active users
type ActiveAccount @entity {
  " { daily/hourly }-{ Address of the account }-{ Days/hours since Unix epoch } "
  id: ID!
}

#########################
##### Savvy Account #####
#########################

type Account @entity @regularPolling {
  " The address of the account "
  id: ID!

  " Total deposited in Savvy in USD "
  totalDepositedUSD: BigInt!

  " Total outstanding debt from Savvy in USD "
  totalDebtUSD: BigInt!
  
  "The timestamp of the last update"
  lastUpdatedTimestamp: BigInt!
}

type AccountSnapshot @entity {
  " { The address of the account }-{ snapshot timestamp }"
  id: ID!
  
  "The time between snapshots in seconds"
  period: BigInt!
  
  " The timestamp of the snapshot "
  timestamp: BigInt!

  " Total deposited in Savvy in USD "
  totalDepositedUSD: BigInt!

  " Total outstanding debt from Savvy in USD "
  totalDebtUSD: BigInt!
}

type AccountBalance @entity {
  " { Account Address }-{ Synthetic Type } "
  id: ID!

  " The account that this balance belongs to "
  account: Account!

  " The synthetic type this balance is referring to (e.g. USD, ETH, BTC ) "
  syntheticType: String!

  " The outstanding debt in amount of SPM Synthetic (e.g. svUSD)"
  debt: BigInt!

  " The outstanding debt in USD "
  debtUSD: BigInt!

  " The total amount deposited in SPM in USD "
  totalDepositedUSD: BigInt!
  
  "The timestamp of the last update"
  lastUpdatedTimestamp: BigInt!
}

type AccountBalanceSnapshot @entity {
  " { Account Address }-{ Synthetic Type }-{ Snapshot timestamp } "
  id: ID!
    
  "The time between snapshots in seconds"
  period: BigInt!
  
  " The timestamp of the snapshot "
  timestamp: BigInt!

  " The account that this balance belongs to "
  account: Account!

  " The synthetic type this balance is referring to (e.g. USD, ETH, BTC ) "
  syntheticType: String!

  " The outstanding debt in amount of SPM Synthetic (e.g. svUSD)"
  debt: BigInt!

  " The outstanding debt in USD "
  debtUSD: BigInt!

  " The total amount deposited in SPM in USD "
  totalDepositedUSD: BigInt!
}

type StrategyBalance @entity {
  " { Account Address }-{ Synthetic Type }-{ Strategy Address } "
  id: ID!

  " The account balance that this strategy balance belongs to "
  accountBalance: AccountBalance!

  " The yield strategy that this balance represents "
  strategy: Strategy!

  " The amount deposited in this strategy "
  amountDeposited: BigInt!

  " The amount deposited in this strategy in USD "
  amountDepositedUSD: BigInt!

  "The timestamp of the last update"
  lastUpdatedTimestamp: BigInt!
}

type StrategyBalanceSnapshot @entity {
  " { Account Address }-{ Synthetic Type }-{ Strategy Address }-{ Snapshot Timestamp } "
  id: ID!
  
  " The account balance that this strategy balance belongs to "
  accountBalance: AccountBalance!
  
  "The time between snapshots in seconds"
  period: BigInt!
  
  " The timestamp of the snapshot "
  timestamp: BigInt!

  " The yield strategy that this balance represents "
  strategy: Strategy!

  " The amount deposited in this strategy "
  amountDeposited: BigInt!

  " The amount deposited in this strategy in USD "
  amountDepositedUSD: BigInt!
}

type Strategy implements Contract @entity {
  " Strategy(Yield Token) Address "
  id: ID!

  " Base token address "
  baseTokenAddress: Bytes
}

##################################
##### Savvy Position Manager #####
##################################

type SPMDeposit implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  yieldToken: Bytes! # address
  amount: BigInt!
  recipient: Bytes! # address
}

type SPMBorrow implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  owner: Bytes! # address
  amount: BigInt!
  recipient: Bytes! # address
}

type SPMRepay implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  repayer: Bytes! # address
  repayWith: String! # "DebtToken, BaseToken, Collateral"
  repayToken: Bytes! # address
  repayTokenAmount: BigInt!
  credit: BigInt!
  recipient: Bytes! # address
}

type SPMWithdraw implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  owner: Bytes! # address
  yieldToken: Bytes! # address
  shares: BigInt!
  recipient: Bytes! # address
}

################
## Savvy Sage ##
################

type SageSetFlowRateEvent implements Event @entity @transaction {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: Protocol!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  " The base token being set "
  baseToken: String!

  " The flow rate for the base token "
  flowRate: BigInt!
}

################
## Savvy Swap ##
################

type SSDeposit implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  recipient: Bytes! # address
  amount: BigInt!
}

type SSWithdraw implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  recipient: Bytes! # address
  amount: BigInt!
}

type SSClaim implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  recipient: Bytes! # address
  amount: BigInt!
}

type SSSwap implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  amount: BigInt!
}

################
## Savvy VeSVY ##
################

type VeSStaked implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  sender: Bytes! # address
  user: Bytes! # address
  amount: BigInt!
}

type VeSUnstaked implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  user: Bytes! # address
  amount: BigInt!
}

type VeSClaimed implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  user: Bytes! # address
  amount: BigInt!
}

################
## Savvy Booster ##
################

type SBDeposit implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  amount: BigInt!
  poolId: BigInt! # address
}

type SBWithdraw implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  amount: BigInt!
}

type SBClaim implements Event @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  transaction: Transaction!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  block: Block!

  " Timestamp of this event "
  timestamp: BigInt!

  user: Bytes! # address
  rewardAmount: BigInt!
  pendingAmount: BigInt!
}
